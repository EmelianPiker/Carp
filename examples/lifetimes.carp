(Debug.sanitize-addresses)
(Project.config "print-ast" true)

;; A function accepting two refs and returning one of them
;; (defn two-refs [x a b]
;;   (if x
;;     (the (Ref t q) a)
;;     (the (Ref t w) b)))



;; (defn unique []
;;   (let [r1 (the &String "DATA")
;;         r2 (the &String "DATA") ;; should get another lifetime variable than r1
;;         r3 "DATA"]
;;     ()))


;; (defn fool [s1 s2]
;;   (let [r1 (the (Ref String Static) s1)
;;         r2 (the (Ref String b) s2)]
;;     (do
;;       (if (= r1 r2) () ())
;;       ;;(delete s1)
;;       ;;(= r1 r2)
;;       ;;()
;;       r2)))


;; This should be detected as an error too:
(defn f [s]
  &s)
(f @"hej")



(defn dangling-1 []
  (let [b [1 2 3]]
    &b)) ;; <- &b : (Ref (Array Int) "b")

(defn dangling-2 []
  (let [b [1 2 3]
        r &b] ;; <- r : (Ref (Array Int) "b")
    r))

(defn dangling-3 []
  (let [r &[1 2 3]] ;; <- r : (Ref (Array Int) "_01")
    r))

;; Not working?
(defn dangling-4 [s]
  &(the String s))

(defn not-dangling-1 [xs] ;; <- xs : (Ref (Array Int) "xs")
  (let [r (Array.nth xs 0)]
    r))

(defn dangling-5 [xs] ;; <- xs : (Array Int)
  (let [r (Array.nth &xs 0)] ;; <- r : (Ref (Array Int) "xs")
    r))

(defn dangling-6 []
  (fn [x]
    (let-do [r &x]
      (String.delete x)
      r)))

;; Not working:
(defn dangling-7 []
  (fn [x]
    &(the String x)))

;; Not working either!
(defn dangling-8 []
  &[1 2 3])



(defn thread [x r]
  (let [r2 (the (Ref a b) r)]
    x))

(defn annoying-problem []
  (let [b [1 2 3]
        r &b]
    (thread b r))) ;; <- This used to cause problems since 'r' depends on 'b' being alive, and 'b' is consumed by thread "before" passing 'r'.
